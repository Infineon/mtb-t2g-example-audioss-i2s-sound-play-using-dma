/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "cyhal.h"
#include "cybsp.h"
#include "cy_retarget_io.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/
typedef struct
{
    uint32_t riff;         /* offset: 0,  size: 4, Indicates type RIFF value = 'RIFF */
    uint32_t size;         /* offset: 4,  size: 4, file size - 8 */
    uint32_t type;         /* offset: 8,  size: 4, = 'WAVE' */
    uint32_t id;           /* offset: 12, size: 4, Format chunk marker. Includes trailing null */
    uint32_t chanksize;    /* offset: 16, size: 4, chunk data size (16) */
    uint16_t format;       /* offset: 20, size: 2, Type of format (1 is PCM) - 2 byte integer */
    uint16_t channels;     /* offset: 22, size: 2, Number of Channels - 2 byte integer */
    uint32_t samplerate;   /* offset: 24, size: 4, Sample Rate */
    uint32_t bytepersec;   /* offset: 28, size: 4, (Sample Rate * BitsPerSample * Channels) / 8 */
    uint16_t blockalign;   /* offset: 30, size: 2, data block size */
    uint16_t bitswidth;    /* offset: 32, size: 2, Bits per sample */
    uint32_t data;         /* offset: 36, size: 4, "data" */
    uint32_t bytesize;     /* offset: 40, size: 4, Size of the data section */
} stc_wav_header;

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* Wave format header size */
#define WAV_HEADER_SIZE (sizeof(stc_wav_header))

/* Data Wire configurations */
#define DW_DEST_COUNT_BIT_NUM   (8ul)
#define DW_DEST_COUNT_MAX       (1ul << DW_DEST_COUNT_BIT_NUM)
#define DW_DEST_COUNT_XY_MAX    (1ul << (DW_DEST_COUNT_BIT_NUM*2))
#define DW_DEST_COUNT_MASK      (DW_DEST_COUNT_MAX - 1ul)
#define DW_DEST_COUNT_XY_MASK   (DW_DEST_COUNT_XY_MAX - 1ul)
#define DW_DESCRIPTOR_NUM       (512)

#define UART_IRQ_PRIORITY       (3)
#define DELAY_BETWEEN_READ_MS   (100)

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* Variable to indicate receive data is available or not */
volatile bool   g_uartReadFlag = false;

/* Variable to indicate the sound is playing or not */
volatile bool   g_playingSound;

/* WAVE data */
const uint8_t WAVE_16_DATA[] =
{
    #include "wavsource.inc"
};

/* DW Descriptors */
CY_ALIGN(32) static cy_stc_dma_descriptor_t DW_I2S_Descriptor[DW_DESCRIPTOR_NUM];

/* DMA Channel Configuration */
const cy_stc_dma_channel_config_t DW_I2S_CH_CONFIG =
{
    .descriptor = DW_I2S_Descriptor,
    .preemptable = false,
    .priority = 0,
    .enable = true,
    .bufferable = false,
};

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/**********************************************************************************************************************
 * Function Name: check_Audio_DataIntegrity
 * Summary:
 *  Checks WAVE data correctness
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void check_Audio_DataIntegrity(void)
{
    stc_wav_header* pWavHeader = (stc_wav_header*)WAVE_16_DATA;
    if (memcmp((void*)&pWavHeader->riff, "RIFF", 4) != 0)
    {
        CY_ASSERT(0);
    }
    if (memcmp((void*)&pWavHeader->type, "WAVE", 4) != 0)
    {
        CY_ASSERT(0);
    }
    if (pWavHeader->format != 1/*PCM*/)
    {
        CY_ASSERT(0);
    }
    if ((pWavHeader->channels != 1) && (pWavHeader->channels != 2))
    {
        CY_ASSERT(0);
    }
    if (pWavHeader->bitswidth != 16)
    {
        CY_ASSERT(0);
    }
}

/**********************************************************************************************************************
 * Function Name: prepare_Dw_Descriptor_Stereo
 * Summary:
 *  Prepares DE descriptors
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void prepare_Dw_Descriptor_Stereo(void)
{
    uint16_t*       pSoundData      = (uint16_t*)&WAVE_16_DATA[WAV_HEADER_SIZE];
    stc_wav_header* pWavHeader      = (stc_wav_header*)WAVE_16_DATA;
    uint32_t        soundPcmNumber  = (pWavHeader->size + 8 - WAV_HEADER_SIZE) / 2;
    uint32_t restDataSize = soundPcmNumber;
    uint32_t counter = 0ul;

    DW_I2S_Descriptor_0_config.dstAddress = (uint32_t *)&((I2S_Type*)CE_I2S_HW)->TX_FIFO_WR;
    DW_I2S_Descriptor_0_config.srcXincrement = 1ul;

    while (restDataSize > 0)
    {
        uint32_t startPoint = soundPcmNumber - restDataSize;
        DW_I2S_Descriptor_0_config.srcAddress = &pSoundData[startPoint];
        if (restDataSize > DW_DEST_COUNT_XY_MAX)
        {
            DW_I2S_Descriptor_0_config.xCount = DW_DEST_COUNT_MAX;
            DW_I2S_Descriptor_0_config.yCount = DW_DEST_COUNT_MAX;
            DW_I2S_Descriptor_0_config.srcYincrement = DW_DEST_COUNT_MAX;
            restDataSize -= DW_DEST_COUNT_XY_MAX;
            if (restDataSize != 0)
            {
                DW_I2S_Descriptor_0_config.nextDescriptor = &DW_I2S_Descriptor[counter + 1];
            }
            else
            {
                DW_I2S_Descriptor_0_config.nextDescriptor = &DW_I2S_Descriptor[0];
            }
        }
        else if (restDataSize > DW_DEST_COUNT_MAX)
        {
            DW_I2S_Descriptor_0_config.xCount = DW_DEST_COUNT_MAX;
            DW_I2S_Descriptor_0_config.yCount = restDataSize >> DW_DEST_COUNT_BIT_NUM;
            DW_I2S_Descriptor_0_config.srcYincrement = DW_DEST_COUNT_MAX;
            restDataSize -= DW_DEST_COUNT_MAX * DW_I2S_Descriptor_0_config.yCount;
            if (restDataSize != 0)
            {
                DW_I2S_Descriptor_0_config.nextDescriptor = &DW_I2S_Descriptor[counter + 1];
            }
            else
            {
                DW_I2S_Descriptor_0_config.nextDescriptor = &DW_I2S_Descriptor[0];
            }
        }
        else
        {
            DW_I2S_Descriptor_0_config.xCount = restDataSize;
            DW_I2S_Descriptor_0_config.yCount = 1;
            DW_I2S_Descriptor_0_config.srcYincrement = restDataSize;
            DW_I2S_Descriptor_0_config.nextDescriptor = &DW_I2S_Descriptor[0];
            restDataSize = 0ul;
        }

        Cy_DMA_Descriptor_Init(&DW_I2S_Descriptor[counter], &DW_I2S_Descriptor_0_config);
        counter++;
    }
    SCB_CleanDCache(); /* Flush the data included in DCache because DMA also reads descriptor in the SRAM */
}

/**********************************************************************************************************************
 * Function Name: setup_Sound
 * Summary:
 *  Setups DMA and I2S to play WAVE sound
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void setup_Sound(void)
{
    /*******************************************
     *   Initialize DW dedicated to I2S
     *******************************************
     */
    /* Check WAVE data integrity */
    check_Audio_DataIntegrity();

    /* Prepare DW descriptors */
    prepare_Dw_Descriptor_Stereo();

    if (Cy_DMA_Channel_Init(DW_I2S_HW, DW_I2S_CHANNEL, &DW_I2S_CH_CONFIG) != CY_DMA_SUCCESS)
    {
        CY_ASSERT(0);
    }
    Cy_DMA_Channel_Enable(DW_I2S_HW, DW_I2S_CHANNEL);
    Cy_DMA_Enable(DW_I2S_HW);

    /* Setting Trigger Mux */
    if (Cy_TrigMux_Select(TRIG_OUT_1TO1_5_I2S_TX_TO_PDMA11, false, TRIGGER_TYPE_LEVEL) != CY_TRIGMUX_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /*******************************************
     *   Initialize I2S
     *******************************************
     */
    if (Cy_I2S_Init(CE_I2S_HW, &CE_I2S_config) != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }
}

/**********************************************************************************************************************
 * Function Name: start_Sound
 * Summary:
 *  Starts playing WAVE sound
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void start_Sound(void)
{
    Cy_I2S_EnableTx(CE_I2S_HW);
    printf("<playing>\r\n");
    g_playingSound = true;
}

/**********************************************************************************************************************
 * Function Name: stop_Sound
 * Summary:
 *  Stops playing WAVE sound
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void stop_Sound(void)
{
    Cy_I2S_DisableTx(CE_I2S_HW);
    printf("<paused>\r\n");
    g_playingSound = false;
}

/**********************************************************************************************************************
 * Function Name: handle_UART_Event
 * Summary:
 *  UART event handler callback function. Sets the read flag to true upon successful reception of data.
 * Parameters:
 *  handlerArg - argument for the handler provided during callback registration
 *  event - interrupt cause flags
 * Return:
 *  none
 **********************************************************************************************************************
 */
 void handle_UART_Event(void *handlerArg, cyhal_uart_event_t event)
{
    (void)handlerArg;

    if (CYHAL_UART_IRQ_RX_DONE == (event & CYHAL_UART_IRQ_RX_DONE))
    {
        /* Set read flag */
        g_uartReadFlag = true;
    }
    else
    {
        CY_ASSERT(0);
    }
}

/**********************************************************************************************************************
 * Function Name: process_Key_Press
 * Summary:
 *  Function to process the key pressed. Depending on the command passed as parameter, new compare values are calculated.
 *  The values are written to the respective buffer registers and a compare swap is issued.
 * Parameters:
 *  keyPressed - command read through terminal
 * Return:
 *  none
 **********************************************************************************************************************
 */
void process_Key_Press(char keyPressed)
{
    if (keyPressed == 'p')
    {
        if (g_playingSound)
        {
            stop_Sound();
        }
        else
        {
            start_Sound();
        }
    }
}

/**********************************************************************************************************************
 * Function Name: main
 * Summary:
 *  This is the main function.
 * Parameters:
 *  none
 * Return:
 *  int
 **********************************************************************************************************************
 */
int main(void)
{
    char uart_read_value; /* Variable to store the read command through UART */

    /* Initialize the device and board peripherals */
    if (cybsp_init() != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    
    /* Enable global interrupts */
    __enable_irq();

    /* Initialize retarget-io to use the debug UART port */
    if (cy_retarget_io_init(CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX, CY_RETARGET_IO_BAUDRATE) != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* The UART callback handler registration */
    cyhal_uart_register_callback(&cy_retarget_io_uart_obj, handle_UART_Event,
                                 NULL);

    /* Enable UART events to get notified on receiving
     * RX data and on RX errors */
    cyhal_uart_enable_event(&cy_retarget_io_uart_obj,
                            (cyhal_uart_event_t)(CYHAL_UART_IRQ_RX_ERROR |
                            CYHAL_UART_IRQ_RX_DONE),
                            UART_IRQ_PRIORITY, true);

    /* \x1b[2J\x1b[;H - ANSI ESC sequence for clear screen */
    printf("\x1b[2J\x1b[;H");

    printf("****************** "
           "AUDIOSS I2S Sound Play using DMA "
           "****************** \r\n\n");
    printf("press 'p' to start/stop the sound\r\n");

    setup_Sound();
    start_Sound();

    for (;;)
    {
        /* Begin asynchronous RX read */
        cyhal_uart_read_async(&cy_retarget_io_uart_obj,
                              (void*) &uart_read_value,
                              sizeof(uart_read_value));

        /* Check if the read flag has been set by the callback */
        if (g_uartReadFlag)
        {
            /* Clear read flag */
            g_uartReadFlag = false;

            /* Process the command and modify the compare values to change the
             * duty cycle and phase.
             */
            process_Key_Press(uart_read_value);
        }

        /* Delay between next read */
        cyhal_system_delay_ms(DELAY_BETWEEN_READ_MS);
    }
}

/* [] END OF FILE */
